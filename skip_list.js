// Generated by CoffeeScript 1.7.1
(function() {
  var SkipEdge, SkipList, SkipNode, _ref;

  _ref = require('./nodes'), SkipNode = _ref.SkipNode, SkipEdge = _ref.SkipEdge;

  SkipList = (function() {
    function SkipList() {
      this._heads = [];
      this._new_head();
      this._size = 0;
    }

    SkipList.prototype._new_head = function() {
      var new_edge, new_head;
      new_head = new SkipNode();
      new_edge = new SkipEdge(0);
      new_head.set_next(null, new_edge, 1);
      if (this._heads.length) {
        new_head.down = this._heads[this._heads.length - 1];
      }
      return this._heads.push(new_head);
    };

    SkipList.prototype.size = function() {
      return this._size;
    };

    SkipList.prototype.insert = function(element) {
      var comparison, current, current_head, current_index, find_result, left_distance, left_index, left_node, new_index, new_node, newer_node, old_distance, previous, right_distance, right_edge, right_node, _results;
      find_result = this._find(element);
      left_node = find_result.node;
      if (left_node.element) {
        comparison = element.compare(left_node.element);
        if (comparison === 0) {
          throw Error("Element already present");
        }
      }
      this._size += 1;
      new_node = new SkipNode();
      new_node.element = element;
      right_node = left_node.next();
      left_node.set_next(new_node, left_node.right_edge, 1);
      right_edge = new SkipEdge(1);
      if (right_node) {
        new_node.set_next(right_node, right_edge, 1);
      } else {
        new_node.set_next(null, right_edge, 1);
      }
      current_head = 1;
      while (Math.random() < 0.5) {
        if (current_head === this._heads.length) {
          this._new_head();
        }
        previous = this._heads[current_head];
        current = previous.next();
        current_index = previous.right_edge.distance - 1;
        while (current && current.element.compare(element) < 0) {
          previous = current;
          current = previous.next();
          current_index += previous.right_edge.distance;
        }
        newer_node = new SkipNode();
        newer_node.element = element;
        newer_node.down = new_node;
        old_distance = previous.right_edge.distance;
        left_index = current_index - previous.right_edge.distance;
        new_index = find_result.index;
        left_distance = new_index - left_index + 1;
        previous.set_next(newer_node, previous.right_edge, left_distance);
        if (current) {
          right_distance = old_distance - left_distance + 1;
          right_edge = new SkipEdge(right_distance);
          newer_node.set_next(current, right_edge, right_distance);
        } else {
          right_edge = new SkipEdge(1);
          newer_node.set_next(null, right_edge, 1);
        }
        new_node = newer_node;
        current_head += 1;
      }
      _results = [];
      while (current_head < this._heads.length) {
        previous = this._heads[current_head];
        current = previous.next();
        while (current && current.element.compare(element) < 0) {
          previous = current;
          current = previous.next();
        }
        if (previous.right_edge.right_node) {
          previous.set_next(current, previous.right_edge, previous.right_edge.distance + 1);
        }
        _results.push(current_head += 1);
      }
      return _results;
    };

    SkipList.prototype.find = function(element) {
      var result;
      result = this._find(element);
      if (result.node.element.compare(element) !== 0) {
        return -1;
      }
      return result.index;
    };

    SkipList.prototype.rank = function(index) {
      var result;
      if (index < 0 || index >= this._size) {
        return null;
      }
      result = this._rank(index);
      return result.element;
    };

    SkipList.prototype.remove = function(index) {
      var distance, element, far_edge, frontier, next_past_target, node, target_element, _i, _len, _ref1;
      if (index < 0 || index >= this._size) {
        return false;
      }
      _ref1 = this._rank(index - 1), element = _ref1.element, frontier = _ref1.frontier;
      target_element = frontier[frontier.length - 1].next().element;
      for (_i = 0, _len = frontier.length; _i < _len; _i++) {
        node = frontier[_i];
        if (!node.next()) {
          continue;
        }
        if (index === 0) {
          next_past_target = node.right_edge.distance > 1;
        } else if (target_element) {
          next_past_target = node.next().element.compare(target_element) > 0;
        } else {
          next_past_target = false;
        }
        if (next_past_target) {
          node.right_edge.distance -= 1;
        } else {
          far_edge = node.next().right_edge;
          if (!node.element && !far_edge.right_node) {
            this._heads.pop();
          } else {
            distance = !far_edge.right_node ? 1 : far_edge.distance + node.right_edge.distance - 1;
            node.set_next(far_edge.right_node, node.right_edge, distance);
          }
        }
      }
      this._size -= 1;
      if (this._size === 0) {
        this._new_head();
      }
      return true;
    };

    SkipList.prototype._rank = function(index) {
      var element, first, frontier, num_left, search;
      frontier = [];
      search = function(node, num_left) {
        if (num_left === 0) {
          frontier.push(node);
          if (node.down) {
            return search(node.down, 0);
          } else {
            return node.element;
          }
        }
        if (node.right_edge.distance <= num_left && node.next()) {
          return search(node.next(), num_left - node.right_edge.distance);
        } else {
          frontier.push(node);
          return search(node.down, num_left);
        }
      };
      num_left = index + 1;
      first = this._heads[this._heads.length - 1];
      element = search(first, num_left);
      return {
        element: element,
        frontier: frontier
      };
    };

    SkipList.prototype._find = function(element) {
      var comparison, current, index, previous;
      previous = this._heads[this._heads.length - 1];
      current = previous.next();
      index = -1;
      while (true) {
        if (!current) {
          if (previous.down) {
            previous = previous.down;
            current = previous.next();
            continue;
          } else {
            return {
              'node': previous,
              'index': index
            };
          }
        }
        comparison = current.element.compare(element);
        if (comparison === 0) {
          index += previous.right_edge.distance;
          while (current.down) {
            current = current.down;
          }
          return {
            'node': current,
            'index': index
          };
        } else if (comparison > 0) {
          if (previous.down) {
            previous = previous.down;
            current = previous.next();
            continue;
          } else {
            return {
              'node': previous,
              'index': index
            };
          }
        } else {
          index += previous.right_edge.distance;
          previous = current;
          current = previous.next();
        }
      }
    };

    SkipList.prototype.to_list = function() {
      var current, element_list;
      element_list = [];
      current = this._heads[0].next();
      while (current) {
        element_list.push(current);
        current = current.next();
      }
      return element_list;
    };

    SkipList.prototype.visualize = function() {
      var current, head, index, row, _i, _len, _ref1;
      console.log("################~BEGIN~##############");
      _ref1 = this._heads;
      for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
        head = _ref1[index];
        current = head.next();
        row = index + '=' + head.right_edge.distance + '=';
        while (current) {
          row += '(' + current.element.value + ')';
          if (current.down) {
            row += 'd';
          }
          if (current.right_edge) {
            row += '-' + current.right_edge.distance + '-';
          }
          current = current.next();
        }
        console.log(row);
      }
      return console.log("################~END~##############");
    };

    return SkipList;

  })();

  module.exports = {
    SkipList: SkipList
  };

}).call(this);

//# sourceMappingURL=skip_list.map
